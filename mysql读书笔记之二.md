[toc]
# mysql读书笔记之二

标签（空格分隔）： mysql

---

## 1、索引（在mysql中也叫键）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。
在mysql中，索引是在存储引擎层儿不是在服务器层实现的，所以，并没有统一的索引标准：不同储存引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。

## 2、索引类型：
不同存储引擎的索引的工作方式不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。
### 2.1 B-Tree索引
B-Tree索引通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。适合查找范围数据。
可以使用B-Tree索引的查询类型：
1）全值匹配
2）匹配最左前缀
3）匹配列前缀
4）匹配范围值
5）精确匹配某一列并范围匹配另外一列
6）只访问索引的查询

关于B-Tree索引的限制：
1）如果不是按照索引的最左列开始查找，则无法使用索引
2）不能跳过索引中的列
3）如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。

可见，索引列的顺序多么重要。

### 2.2 哈希索引
哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。在mysql中，只有memory引擎显式支持哈希索引，这也是memory引擎表默认索引类型，memory引擎同时也支持B-Tree索引。
另外需要注意：memory引擎是支持非唯一哈希索引的。

哈希索引有自己的限制：
1）哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行速度很快，所以大部分情况下这一点对性能的影响并不明显。
2）哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
3）哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
4）哈希索引只支持等值比较查询，包括=，IN(),<=>（注意<>和<->是不同的操作）。也不支持任何范围查询。
5）访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中的所有的行指针，逐行进行比较，直到找到所有符合条件的行。
6）如果哈希冲突很多的话，一些索引维护操作的代价会很高。

举例：创建自定义的哈希索引:
本来的语句是
select id from url where url="http://www.mysql.com";
现在用自定义的哈希索引（新加一个被索引的url_crc列，使用crc32做哈希）：
select id from url where url="http://www.mysql.com" and url_crc=crc32("http://www.mysql.com");


这种实现的缺陷是需要维护哈希值，可以手动维护，也可以在触发器实现。
触发器：
```
delimiter //
create trigger tb_url_ins before insert on tb_url for each row begin
set NEW.url_crc=crc32(NEW.url);
end;
//
create trigger tb_url_upd before update on tb_url for each row begin
set NEW.url_crc=crc32(NEW.url);
end;
//
delimiter ;
```

如果采用这种方式，记住不要使用sha1()和md5()来作为哈希函数。因为这两个函数计算处理的哈希值是非常长的字符串，会浪费大量空间，比较时也更慢。
如果数据表非常大，crc32()会出现大量的哈希冲突，则可以考虑自己实现一个简单的64位哈希函数，返回整数而非字符串。
一个简单的方法：
select conv(right(md5('http://www.mysql.com'),16),16,10) as hash4;

注意：要避免冲突问题，必须要在where条件中带入哈希值和对应列值。
但是，如果只是粗略统计记录数，可以不带列值。

### 2.3 空间数据索引

### 2.4 全文索引

全文索引是一种特殊类型的索引，他查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样，他有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引给那个类似于搜索引擎做的事情，而不是简单的where条件匹配。
### 2.5 其他索引类别
还有很多第三方的存储引擎使用不同类型的数据结构来存储索引。如：TokuDB使用分形树索引。




## 3、操作符<=>
1)和=号的相同点:
　　像常规的=运算符一样，两个值进行比较，结果是0（不等于）或1（相等）;换句话说：’A'<=>’B'得0和’a'<=>’a‘得1。
　和=号的不同点:
　　和=运算符不同的是，NULL的值是没有任何意义的。所以=号运算符不能把NULL作为有效的结果。所以：请使用<=>,
　　'a' <=> NULL 得0   NULL<=> NULL 得出 1。和=运算符正相反，=号运算符规则是 'a'=NULL 结果是NULL 甚至NULL = NULL 结果也是NULL。顺便说一句，mysql上几乎所有的操作符和函数都是这样工作的，因为和NULL比较基本上都没有意义。
2)用处
　　当两个操作数中可能含有NULL时，你需要一个一致的语句。
... WHERE col_a <=> ? ...
　　这里的占位符有可能是常量也有可能是NULL，当使用<=>运算符时，你没有必要对查询语句做任何修改。
3)相关操作符
　　除了 <=> ，还有两个其他的操作符用来处理某个值和NULL做比较，也就是IS NULL and IS NOT NULL。他们是ANSI标准中的一部分，因此也可以用在其他数据库中。而<=>只能在mysql中使用。
　　你可以把<=>当作mysql中的方言。
'a' IS NULL     ==> 'a' <=> NULL

'a' IS NOT NULL ==> NOT('a' <=> NULL)

## 4、索引的优点：
1）索引大大减少了服务器需要扫描的数据量
2）索引可以帮助服务器避免排序和临时表
3）索引可以讲随机I/O变为顺序I/O.

索引并不总是最好的工具。

## 5、高性能的索引策略
### 5.1 独立的列
独立的列指的是索引列不能是表达式的一部分，也不能是函数的参数。我们应该始终把索引列单独放在比较符号的一侧。
eg:
```
select id from user where id+1=5;
select .. from todays where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <=10;
```

### 5.2 前缀索引和索引的选择性
通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。
索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以在查找时候过滤掉更多的行，唯一索引的选择性是1。
对于BLOB,TEXT或者很长的VARCHAR类型的列，必须使用前缀索引。因为mysql不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话来说，前缀的“基数”应该接近于完整列的“基数”。

注意：前缀索引是一种能使得索引更小，更快的有效办法，但另外一方面也有缺点：mysql无法使用前缀索引做order by 和group by，也无法使用前缀前缀索引做覆盖扫描。

eg:
```
//计算完整列的选择性
select count(distinct city)/count(*) from city_demo;
//然后示例来找到前缀选择性最接近于完整列的选择性
select count(distinct left(city,3))/count(*) as sel3,
count(distinct left(city,4))/count(*) as sel4,
count(distinct left(city,5))/count(*) as sel5,
count(distinct left(city,6))/count(*) as sel6,
count(distinct left(city,7))/count(*) as sel7,
from city_demo;
```

有时候后缀索引也有用途，比如找到某个域名的素有电子邮件地址。mysql原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器来维护这种索引（可以参考创建自定义哈希索引）。

### 5.3 多列索引
eg:
```
select film_id,actor_id from film_actor where actor_id=1 or film_id=1;
可以优化为：
select film_id,actor_id from film_actor where actor_id=1 union all  
select film_id,actor_id from film_actor where film_id=1 or actor_id<>1;
```

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：
1）当出现服务器对多个索引做相交操作（通常有多个and条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
2）当服务器对多个索引做联合操作（通常是多个or条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是在当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
3）更重要的是，优化器不会把这些计算到查询成本，优化器只关心随机页面读取，这使得查询成本被低估，导致该执行计划还不如直接走全表扫描。这不仅会消耗更多的CPU和内存资源，还可能会影响查询的并发性。
如果在explain中有看到索引集合，应该好好检查下查询和表的结构，看是不是已经最优，也可以通过参数optimizer_switch来关闭索引合并功能。也可以使用ignore index提示让优化器忽略掉某些索引。

### 5.4 选择合适的索引列顺序
对于如何选择索引列的顺序有一个经验法则：将选择性最高的列放在索引最前列，这个建议在某些场景中可能有帮助，但是通常不如避免随机I/O和排序那么重要，考虑问题要更全面。
性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。

### 5.5 聚簇索引（162页）
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于实现方式，但innodb的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
当表有聚簇索引时，他的数据行实际存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时吧数据行存放在两个不同的地方，所以一个表只有一个聚簇索引（不过覆盖索引可以模拟多个聚簇索引的情况）。、

因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。

innodb通过主键聚集数据。如果没有定义主键，innodb会选择一个唯一的非空索引代替。如果没有怎的索引，innodb会隐式定义一个主键来作为聚簇索引。innodb只聚集在同一个页面的记录，包含相邻键值的页面可能会相距甚远。

聚簇主键可能会对性能有帮助，也可能导致严重的性能问题。
聚簇的数据一些重要的优点：
1）可以把相关数据保存在一起
2）数据访问更快。聚簇索引将索引和数据都保存在同一个B-Tree中，因此从聚簇索引中获取数据通常要比在非聚簇索引中查找更快
3）使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

聚簇索引额缺点：
1）聚簇数据醉倒限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序没有那么重要了，聚簇索引也就没有什么优势了
2）插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到innodb表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table 命令重新组织一下表。
3）更新聚簇索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置
4）基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中耳朵时候，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分类操作。页分裂会导致占用更多的磁盘空间。
5）聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
6）二级索引（非聚簇索引）可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列
7）二级索引访问需要两次索引查找，而不是一次。因为二次索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。（对于innodb，自适应哈希索引可以减少这样的重复工作）


**myisam的数据分布**：
myisam是按照数据插入的顺序存储在磁盘上的
**innodb的数据分布**：
因为innodb支持聚簇索引，所以使用非常不同的方式来存储同样数据。
聚簇索引额每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC（多版本控制）的回滚指针以及所有剩余列。
如果主键是一个列前缀索引，innodb也会包含完整的主键列和剩余的其他列。

还有一点和myisam不同的是，innodn的二级索引和聚簇索引很不相同。innodb的二级索引的叶子节点存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。


**在innodb中按照主键的顺序插入行。**

### 5.6 覆盖索引
覆盖索引概念：
  MySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)。也就是平时所说的不需要回表操作。
判断标准：
 在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。

注意：覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。Hash、空间索引 和full-text索引不存储值，因此MySQL只能使用B-TREE。并且不同的存储引擎实现覆盖索引都是不同的。并不是所有的存储引擎都支持它们。如果要使用覆盖索引。一定要注意SELECT 列表值取出需要的列。不可以是SELECT * ，因为如果将所有字段一起做索引会导致索引文件过大。查询性能下降。不能为了利用覆盖索引而这么做。

InnoDB中，覆盖索引查询时除了除了索引本身的包含的列，还可以使用其默认的聚集索引列 。这跟INNOB的索引结构有关系。主索引是B+树索引存储。也即我们所说的数据行即索引。索引即数据。这个相对的是主键索引。对于INNODB的辅助索引。它的叶子节点存储的是索引值和指向主键索引的位置。然后需要通过主键在查询表的字段值。所以辅助索引存储了主键的值。覆盖索引也可以用上INNODB默认的聚集索引。

### 5.7 使用索引扫描来做排序
mysql有两种方式可以生成有序的结果，通过排序操作，或者按照索引顺序扫描。
如果explain出来的type列为index,则说明mysql使用了索引扫描来做排序（不要和Extra列的Using index搞混了）。

很容易把Extra列的“Using index”和type列的 “index”搞混淆。其实两者完全不同，type列和覆盖索引没有任何关系，他只是表示这个查询访问数据的方式，或者mysql查找行的方式。mysql手册中称之为连接方式。
而Extra列的“Using index”说明索引覆盖查询。

**不能使用索引的几种情况：**
比如建了索引rental_date(date,inven_id,cust_id)
1）查询使用了两种标题的排序方向，但是索引列都是正序排列的
...where date='2016-10-12' order by inven_id desc,cust_id asc;
2）order by子句中使用了一个不在索引中的列
...where date='2016-10-12' order by inven_id,staff_id asc; 
3）where和order by中的列无法组合成索引的最左前缀
...where date='2016-10-12' order by cust_id;
4）索引列上的第一列上的是范围条件，所以mysql无法使用索引的其余列
...where date>'2016-10-12' order by inven_id,cust_id;
5）下面这个查询在inven_id列上有多个等于条件，对于排序来说，这也是一种范围查询
...where date='2016-10-12' and  inven_id in(1,4) order by cust_id;

**mysql中using的用法为：**
using()用于两张表的join查询，要求using()指定的列在两个表中均存在，并使用之用于join的条件。
示例：
select a.*, b.* from a left join b using(colA);
等同于：
select a.*, b.* from a left join b on a.colA = b.colA;


### 5.8 压缩（前缀压缩）索引（只对myisam）

myisam压缩每个索引块的方法是：先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。
例如：索引块第一个值是"perform",第二个值是"performance"，那么第二个值的前缀压缩后存储的是类似"7,ance"这样的形式。myisam对行指针也采用类似的前缀压缩方式。

http://www.thecreativedev.com/to-learn-mysql-pack-keys-with-example/
**pack_keys**生效只有在是**MyISAM表**的时候才生效。如果要有较小的索引，将此选项设置为1。这通常会使更新速度较慢，读取速度更快。设置选项为0禁用所有的键的压缩。设置为默认存储引擎只压缩CHAR、VARCHAR, BINARY, or VARBINARY列。
如果你不使用pack_keys，默认是压缩字符串索引，而不是数字。如果你使用pack_keys = 1，数字及字符串索引都压缩。
eg；
```
CREATE  TABLE <TABLE_NAME> (
  `id` INT NOT NULL ,
  `name` VARCHAR(250) NULL ,
   PRIMARY KEY (`id`) )
   PACK_KEYS = 1;

//或者
ALTER TABLE table_name PACK_KEYS = 1;
```

### 5.9 冗余和重复索引
重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免，发现以后立即删除。

冗余索引：
举例：
如果创建了索引(a,b),再创建索引(a)就是冗余索引，因为这只是一个索引的前缀索引，因此(a,b)也可以当做索引(a)来使用（这种冗余只是对B-Tree索引来说的）。其他类型的索引（例如哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。
大多数情况下不需要冗余索引，应该尽量扩展已有索引而不是创建新索引，但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有索引会导致其变得很大，从而影响其他使用该索引的查询性能。

还有一种：将一个索引扩展为(a,id)，其中id是主键，对innodb来说主键已经包含在而二级索引中了，索引这也是冗余。


### 5.10 未使用的索引
1）在perconna server或者mariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询information_schema.index_statistics就能查到每个索引使用的频率。
2）使用percona toolkit中的pt-index-usage，该工具可以读取查询日志，然后对日志中的每条查询进行explain操作，然后打印出关于索引和查询的报告。

### 5.11 索引和锁

关于innodb，索引和锁有一些很少人知道的细节：innodb在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）所。这消除了使用覆盖索引的可能性，并且使得select for update 比lock in share mode或者非锁定查询要慢很多。

## 6、索引案例学习
### 6.1 支持多种过滤条件

设计一个在线约会网站，用户信息很多列，包括国家，地区，城市，性别，眼睛颜色，年龄等等。
考虑到几乎所有的查询都要用到国家和性别，我们可以使用(sex,county)列作为前缀索引。
对于某些不限制性别的查询，我们可以在查询条件中新增**sex in('m','f')**来让mysql选择该索引。必须加上这个列的条件，mysql才能匹配索引的最左前缀。（如果列有太多值，这样做就不行了）。

应该同时优化查询和索引以找到最佳的平衡。

### 6.2 避免多个范围条件

什么是范围条件：
从explain很难区分mysql是要查询范围值，还是要查询列表值。explain使用同样的type='range'来描述这两种情况。
eg:
```
explain select id from film where aid>45\G
explain select id from film where aid in(1,2,34)\G
```
效率不同，对于范围条件查询，mysql无法再使用范围列后的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。


示例：
如果有下面的查询条件
where eye_color in('blue', 'black', 'brown')
  and hair_color in('black', 'red', 'yellow', 'brown')
  and sex        in('m', 'f')
  and last_online >date_sub(now(), interval 7 day)
  and age between 18 and 25;
  
last_online和age列，mysql可以使用last_online列索引或者age列索引，但无法同时使用他们。
我们考虑无法把age替换为一个in()列表，并仍要求同时有last_online和age列这两个维度范围查询的速度很快。答案：我们可以事先计算好一个**active列，这个字段由定时任务来维护，当yoghurt每次登录的时候，将对应值设置为1，并且将过去连续7天未曾登录的用户的值设置为0**。
当然active列并不完全精确，但对于这个查询，对精确度要求没有那么高。
  
  
#### 6.2.1 DATE_SUB

    DATE_SUB(date,INTERVAL expr type)

date 参数是合法的日期表达式。expr 参数是您希望添加的时间间隔。
type 参数可以是下列值：
```
Type 值
MICROSECOND
SECOND
MINUTE
HOUR
DAY
WEEK
MONTH
QUARTER
YEAR
SECOND_MICROSECOND
MINUTE_MICROSECOND
MINUTE_SECOND
HOUR_MICROSECOND
HOUR_SECOND
HOUR_MINUTE
DAY_MICROSECOND
DAY_SECOND
DAY_MINUTE
DAY_HOUR
YEAR_MONTH
```
eg:
SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate
FROM Orders;

### 6.3 优化排序

使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上百万行就不行了。
示例：
可以创建索引(sex,rating)用于下面的查询：
select <cols> from profiles where sex='m' order by rating limit 10;

即使有索引，如果用户界面需要翻页，并且翻页翻到比较靠后时候查询也可能非常慢，如下：
select <cols> from profiles where sex='m' order by rating limit 100000,10;

无论如何创建索引，这种查询都是严重问题。因为随着偏移量的增加，mysql需要花费大量的时间来扫描需要丢弃的数据。**反范式化、预先计算和缓存可能是解决这类查询仅有的策略**。一个更好的办法是**限制用户翻页额数量**，实际上这对yoghurt的体验影响不大，因为用户很少会真正在乎搜索结果的10000页。

优化这类索引的另外一个比较好的办法是**延迟关联**，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行，这可以减少mysql扫描那些需要丢弃的行数。如下：
```
select <cols> from profiles inner join(
	select <primary key cols> from profiles
	where x.sex='m' order by rating limit 100000,10
) as x using (<primary key cols>);
```

## 7、维护索引和表
### 7.1 找到并修复损坏的表
可以使用check table来检查是否发生了表损坏（注意有些存储引擎不支持该命令；而有些存储引擎则支持以其他不同的选项来控制完全检查表的方式），check table通常可以找出大多数的表和索引的错误。

可以使用repair table命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令，如果存储引擎不支持可以通过一个不做任何操作的alter操作来重建表。例如：alter table test engine=innodb;

也可以使用一些存储引擎相关的离线工具，例如myisamchk;或者将数据导出一份然后再重新导入，不过如果损坏的是系统区域，或者表的行数据区域，而不是索引，那么上面的方法不行了，只能从备份中恢复表。

innodb的设计保证了他并不容易被损坏，如果发生，一般要么是数据库的硬件问题例如内存或者磁盘问题（有可能），要么是由于数控看管理员的错误例如在mysql外部操作了数据文件（有可能），亦或是innodb本身的缺陷（不大可能）。常见的类似错误通常是由于尝试使用rsync备份innodb导致的。
可以通过innodb_force_recovery参数进入innodb的强制模式来恢复数据。

如果遇到数据损坏，最重要的是找出是什么导致了损坏，而不是简单的修复，否则很有可能还会不断的损坏。

### 7.2 更新索引统计信息
mysql的查询优化器会通过两个api来了解存储引擎的索引值的分布信息，以决定如何使用索引。一个是records_in_range()，通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。第二个api是info()，该接口返回各种类型的数据，包括索引的基数（每个键值有多少条记录）。

可以通过analyze table 来重新生成统计信息。每种存储引擎实现索引统计信息的方式不同，所以需要进行analyze table的频率也因不同的引擎而不同，每次运行的成本也不同：
1）memory引擎根本不存储索引统计信息
2）myisam将索引统计信息存储在磁盘中，analyze table需要进行一次全所以扫描来计算索引基数。在整个过程中需要锁表。
3）知道mysql5.5版本，innodb也不在磁盘中存储索引信息，而是通过随机的索引访问进行评估并将其存储在内存中。

可以通过show index from table来查询索引的基数（cardinality）。其显示了存储引擎估算索引列有多少个不同的取值。另外，也可以通过information schema.statistics表来很方便的查询到这些信息。


### 7.3 减少素有和数据的碎片
表的数据存储可能碎片化。然而，数据存储的碎片化比索引更加复杂。有三种类型的数据碎片：
1）行碎片(row fragmentation)
指的是数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
2）行间碎片(intra-row fragmentation)
指的是逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。
3）剩余空间碎片(free space fragmentation)
指的是数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

对应myisam表，这三类碎片都可能发生。但innodb不会出现短小的行碎片，innodb会移动短小的行并重写到一个片段中。

可以通过执行**optimize table**或者**导出再导入**的方式来重新整理数据，这对多数存储引擎是有效的。对于一些存储引擎诸如**myisam，可以通过排序算法重建索引的方式来消除碎片**。
对不支持optimize table的存储引擎，可以通过一个**不做任何操作的alter table操作来重建表**。


## 8.总结：如何判断一个索引是合理的呢
一般来说，我们建议按照响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器带来最大压力的查询，然后检查这些查询的schema,sql和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用随机i/o访问数据，或者是否有太多回表查询那些不在索引中的列的操作。



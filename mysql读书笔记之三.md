[toc]
# mysql读书笔记之三

标签（空格分隔）： mysql

查询性能优化
查询优化、索引优化、库表结构优化需要齐头并进，一个不落。

## 1、慢查询基础：优化数据访问
对于低效查询，下面两个步骤来分析总是很有效：
1）确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是是访问了太多的列
2）确认mysql服务器层是否在分析大量超过需要的数据行。

### 1.1 是否向数据库请求了不需要的数据
会给mysql服务器带来额外压力，并增加网络开销，另外也会消耗应用服务器的cpu,和内存资源。

一些经典案例：
1）查询不需要的记录，最简答有效的解决办法是加上limit
2）多表关联时返回全部列
3）总是取出全部的列
4）重复查询相同的数据，比如用户评论的列表需要用户头像，反复查询。

### 1.2 mysql是否在扫描额外的记录
最简单的衡量查询开销的三个指标如下：
1）响应时间（服务器时间+排队时间）
2）扫描的行数
3）返回的行数

如果发现查询需要大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化他：
1）使用覆盖索引扫描，把所有需要需要用的列都放在索引中，这样存储引擎无需回表查询对应的行就可以返回结果了
2）改变库表结构。例如使用单独的汇总表
3）重写这个复杂的查询，让mysql优化器能够以更优化的方式执行这个查询。

## 2、重构查询额方式
### 2.1 一个复杂查询还是多个简单查询
### 2.2 切分查询
即大查询分成小查询，每个查询功能完全一样，只完成一小部分，每次只会返回一小部分的查询结果。
比如：定期删除旧的数据。
我们需要：
```
delete from messages where created < date_sub(now(), interval 3 month);
```
那么可以用类似下面的方法来完成同样的工作：
```
rows_affected=0
do{
	rows_affected= do_query(
	"delete from messages where created < date_sub(now(), interval 3 month) limit 10000"
	)
}while rows_affected>0
```

这样可以讲服务器上原本一次性的压力分散扫一个很长的时间段内，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。

### 2.3 分解关联查询
如下面这个查询：
```
select * from tag 
	join tag_post on tag_post.tag_id=tag.id
	join post on tag_post.post_id=post.id
where tag.tag='mysql';
```
可以分解成下面这些查询来代替：
```
select * from tag where tag='mysql';
select * from tag_post where tag_id=1234;
select * from post where post.id in(123,456,567,9098,8904);
```

使用分解关联查询的方式重构查询有以下优势：
1）让缓存的效率更高
2）将查询分解后，执行单个查询可以减少锁的竞争
3）在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
4）查询本身效率也可能会有所提升
5）可以减少冗余记录的查询
6）更进一步，这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景中哈希关联的效率高很多。


## 3、查询执行的基础
查询执行路径：
1）客户端发送一条查询给服务器
2）服务器先查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一个阶段
3）服务器进行sql解析、预处理、再由优化器生成对应的执行计划
4）mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询
5）将结果返回给客户端


### 3.1 mysql客户端/服务器端通信协议
mysql客户端和服务器端的通信协议是“半双工”的。这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器daunting发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。
比如php链接mysql的通常写法如下;
```
$link= mysql_connect('localhost', 'user', 'pwd');
$result = mysql_query('select * from film', $link);
while($row=mysql_fetch_array($result)){
	//do sth
}
```
这段代码看起来似乎是只有当牛需要的时候，才通过循环从服务器端取出额数据。而实际上在调用mysql_query()的时候，php就已经将整个结果集缓存到内存中，下面的while循环只是从缓存中逐行取出数据。相反，如果使用mysql_unbuffered_query()代替，mysql_query()，php则不会缓存结果。


查询状态：
使用show full processlist命令可以查询到当前的状态（其中的Comman列就表示当前的状态）。
如下：
1）Sleep:
线程正在等待客户端发送新的请求
2）Query:
线程正在执行查询或者正在将结果发送给客户端
3）Locked:
在mysql服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如innodb的行锁，并不体现在线程状态中。对于myisam来说这是一个比较经典的状态，但在其他没有行锁的引擎中也经常会出现。
4）Analyzing and statistics
线程正在收集存储引擎的统计信息，并生成查询的执行计划
5）Copying to tmp table [on disk]
线程正在查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做group by 操作，么要是文件排序操作，或者是union操作。如果这个状态后面的还有"on disk"标记，那表示mysql正在将一个内存临时表放到磁盘上。
6)Sorting result
线程正在对结果集进行排序
7）Sending data
这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。

### 3.2 查询缓存(Query Cache)
在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。

### 3.3 查询优化处理
查询的生命周期的下一步是将一个sql转换成一个执行计划，mysql再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析sql,预处理，优化sql执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。在实际执行中，这几部分可能一起执行也可能单独执行。
mysql使用基于成本的优化器，他将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。可以通过查询当前会话的last_query_cost的值来得知mysql计算的当前查询的成本。
例如：
```
select sql_no_cache count(*) from film;
show status like 'last_query_cost';
```
这个结果表示mysql的优化器认为大概需要做xxx个数据页的随机查找才能完成上面的查询，这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的技术（索引中不同值的数量）、索引和数据行的长度、索引分布情况。优化器在评估成本的时候并不考虑任何层面的缓存，他假设读取任何数据都需要一次磁盘i/o。

**导致mysql的优化器会选择错误的执行计划**的原因很多例如：
1）统计信息不准确。mysql依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息偏差很大，比如innodb因为其MVCC(”多版本并发控制“的机制)的架构，并不能维护一个数据表的行数的精确统计信息。

2）执行计划中的成本估算不等同于实际执行的成本。
mysql的最优可能跟你想的最优不一样。你可能希望执行时间尽可能短，但是mysql这是基于其成本模型选择的最优的执行计划，而有些时候这并不是最快的执行方式。
3）mysql从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。
4）mysql并不是任何时候都是基于成本的优化。有时会基于一些固定的规则，比如如果存在全文搜索的match()子句，则在存在全文索引的时候就使用全文索引。即使有时候使用别的索引和where条件可能远比这种方式要快，mysql也依然会使用对应的全文索引。
5）mysql不会考虑不受其控制的成本，例如执行存储过程或者用户自定义函数的成本
6）优化器有时无法去估算所有可能的执行计划，所以他可能错过实际上最优的执行计划，



**优化器**是一个很复杂的部件，他使用了很多优化策略来生成一个最优的执行计划。优化策略简单分为两种，一种是静态优化，一种是动态优化。
**静态优化**可以直接对解析树进行分析，并完成优化。例如优化器可以通过一些简单的代数变换将where条件转换成另一种等价形式。静态优化不依赖于特别的数值，如where条件中带入的一些常数等。静态优化是在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会变化，可以认为是一种“**编译时优化**”。
**动态优化**则和查询的上下文有关，也可能跟很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候都重新评估，可以认为是“**运行时的优化**”。

在执行语句和存储过程的时候，**动态优化和静态优化的区别**很重要。**mysql对查询的静态优化只需要做一次，但对查询的动态优化则在每次执行时都需要重新评估。有时甚至在查询的执行过程中也会重新优化。**

下面是mysql能够处理的优化类型：
1）重新定义关联表的顺序
数据表的关联并不总是按照在查询中指定的顺序进行。
2）将外连接转换成内连接
3）使用等价变换规则
比如(a<b and b=c) and a=5会被改写为：b>5 and b=c and a=5

4）优化count(),min(),max()
5）预估并转化为常熟表达式
eg:
```
explain select film.film_id,actor.actor_id  from film 
	inner join actor.actor_id using (film_id)
where film.film_id =1;
```
6）覆盖索引扫描
7）子查询优化
8）提前终止查询
例如limit
9）等值传播
eg:
```
select film.film_id from film 
	inner join actor using(film_id)
where film.film_id >500;
```
10）列表IN()的比较
等等。


**mysql如何执行关联查询**
在mysql中，每一个查询，每一个片段（包括子查询，甚至基于单表的select）都可能是关联。
比如：对于union查询，mysql先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成union查询。在mysql中，每个查询都是一次关联，所以读取结果临时表也是一次关联。

当前**mysql关联执行的策略**很简单，mysql对任何关联都执行嵌套循环关联操作。


**执行计划**
和很多其他关系型数据库不同，mysql并不会生成查询字节码来执行查询。mysql生成查询的一颗指令树，然后通过存储引擎执行完成这颗指令树并返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行explain extended后，再执行show warnings，就可以看到重构出的查询。
eg:
```
explain extended select * from test;
show warning;
```
可以看到查询被改写成：
```
/* select#1 */ select `test`.`test`.`money` AS `money`,`test`.`test`.`id` AS `id` from `test`.`test`
```

任何多表查询都可以使用一棵树来表示，（平衡树，左侧深度优先树等）。


**关联查询优化器**：
mysql优化器最重要的一部分就是关联查询优化，他决定了多个表关联时的顺序。(其实有多种不同的关联顺序)
比如：
```
explain select film.film.id,film.title,actor.actor_id,actor.aname
from film
inner join film_actor using(film_id)
inner join actor using(actor_id)\G
//这个查询表的执行顺序是actor->film_actor->film
```
我们可以使用`straight_join`来强制制定关联查询表的顺序，如下
```
explain select straight_join film.film.id,film.title,actor.actor_id,actor.aname
from film
inner join film_actor using(film_id)
inner join actor using(actor_id)\G
//这个查询表的执行顺序是film->film_actor->actor
```
例子:
http://huoding.com/2013/06/04/261
首先MySQL优化器要确定以谁为驱动表，也就是说以哪个表为基准，在处理此类问题时，MySQL优化器采用了简单粗暴的解决方法：哪个表的结果集小，就以哪个表为驱动表.

**排序优化：**
无论如何排序都是一个成本很高的操作，所以从性能角度来考虑，应该尽可能避免排序或者尽量避免对大量数据进行排序。
如果需要排序的数据量小于“排序缓冲区”，mysql会使用内存进行“快速排序”操作。如果内存不够排序，那么mysql会先把数据分块，对每个独立块使用“快速排序”进行排序，并将每个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。
mysql有如下两种排序算法：
两次传输排序（旧版本使用）：
读取指针和需要排序的字段，对其进行排序，然后再根据排序结果读取需要的数据行。
单次传输排序（新版本使用）：
先读取需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。

注意：mysql在进行文件排序的时候需要使用的临时存储空间可能比想象的要打很多，原因在于mysql在排序时候，对每一个排序记录都会分配一个足够长的定长空间来存放。


### 3.4 查询执行引擎
实际上，mysql在优化阶段就为每个表创建了一个handler实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名，索引统计信息等等。

注意:并不是所有的操作都由handler完成。例如mysql需要进行表锁的时候，handler可能会实现自己的级别、更细粒度的锁，如innodb就实现了自己的行基本锁，但这并不能代替服务器层的表锁。
如果是所有存储引擎共有的特性由服务器层实现，比如时间和日期函数、视图、触发器等。
### 3.5 返回结果给客户端
即使查询不需要返回结果给客户端，mysql仍然会返回这个查询的一些信息，如影响到的行数等。

如果查询可以被缓存，那么mysql会在这个阶段也将结果存放到查询缓存中。

mysql将结果集返回给客户端是一个增量、逐步返回的过程。例如关联操作，一旦服务器处理完最后一个关联表，开始生成第一条结果时，mysql就可以开始向客户端逐步返回结果了。
这样处理有两个好处：服务器无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。另外，这样的处理也让mysql客户端第一时间获得返回的结果。

结果集中的每一行都会以一个满足mysql客户端/服务器通信协议的封包发送，再通过tcp协议进行传输,在tcp传输的过程中，可能对mysql的封包进行缓存然后批量传输。



## 4、注意：

### 4.1 “多版本并发控制（MVCC）”的机制
你可将MVCC看成行级别锁的一种妥协，它在许多情况下避免了使用锁，同时可以提供更小的开销。根据实现的不同，它可以允许非阻塞式读，在写操作进行时只锁定必要的记录。
MVCC会保存某个时间点上的数据快照。这意味着事务可以看到一个一致的数据视图，不管他们需要跑多久。这同时也意味着不同的事务在同一个时间点看到的同一个表的数据可能是不同的。
各个存储引擎对于MVCC的实现各不相同。这些不同中的一些包括乐观和悲观并发控制。

**比锁定的优势：**
使用MVCC多版本并发控制比锁定模型的主要优点是在MVCC里， 对检索（读）数据的锁要求与写数据的锁要求不冲突， 所以读不会阻塞写，而写也从不阻塞读。
在数据库里也有表和行级别的锁定机制， 用于给那些无法轻松接受 MVCC 行为的应用。 不过，恰当地使用 MVCC 总会提供比锁更好地性能。

### 4.2 派生表

派生表是Microsoft公司新推出的SQL2005数据库的一个增强功能。它将子查询做为一个表来处理，这个由子查询得出的新表就是我们说的“派生表”。

它的出现，使子查询的效率大大提高，对于数据量大的数据系统无疑是一个新的提效手段。
派生表可以在视图中建立与其它表的连接关系，在生成派生表后，在视图中可以看到与普通表一样的一个新增表，和普通表的操作方法一样，也要选择字段。

### 4.3mysql并不支持全外连接





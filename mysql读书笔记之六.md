[toc]
# mysql读书笔记之六

标签（空格分隔）： mysql

---

## 1、分区表基本介绍
对用户来说，分区表是一个独立的逻辑表，但是底层是由多个物理子表来组成的。实现分区的代码实际上是对一组底层表的句柄对象的封装。，对分区表的请求，都会通过句柄对象转换成对存储引擎的接口调用。这也意味着索引也是按照分区的字表定义的，而没有全局索引。
这和oracel不同。在oracle中可以更加灵活的定义索引和表是否进行分区。
分区表一个主要的目的是将数据按照一个较粗的粒度分在不同的表中。这样做可以将相关的数据存放在一起，另外想要一次性批量删除整个分区的数据也会变得很方便。

在下面的场景中，分区表起到非常大的作用：
1）表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
2）分区表的数据更容易维护。例如想批量删除大量数据可以使用清楚整个分区的方式。另外还可以对一个独立分区进行优化、检查、修复等操作。
3）分区表的数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备。
4）可以使用分区表来避免某些特殊的瓶颈。例如innodb的单个索引的互斥访问，ext3文件系统的inode的锁竞争等。
5）如果需要，还可以备份和恢复独立的分区，这在非常大的书记的场景下效果非常好。


分区表本身也有一些限制，下面是比较重要的几点：
1）在mysql5.1中，分区表达式必须是整数，或者是返回整数的表达式。在mysql5.5中，某些场景中可以直接使用列来进行分区。
2）如果分区字段中国有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
3）分区表无法使用外键约束。

## 2、分区表的原理
分区表是由多个相关的底层表实现，这些底层表也是句柄对象表示，所以我们可以直接访问各个分区。存储引擎关联分区的各个底层表和管理普通表一样（所有底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个完全相同的索引。从存储引擎角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是普通表还是分区表的一部分。

分区表上的操作按照下面的操作逻辑进行：
1）select查询
当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。
2）insert操作
当写入一条记录时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应底层表。
3）delete操作
当删除一条记录时候，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。
4）update操作
当更新一条记录时候，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作。


有些操作是支过滤的，delete,update都是先找到这条记录，如果where条件恰好与分区表达式匹配，就会将不包含这条记录的分区都过滤掉。如果是insert，则本身就是只命中一个分区，其余分区都会被过滤掉。

虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁如innodb,则会在分区层释放对应表锁。这个加锁和解锁过程与普通innodb上的查询类似。

## 3、分区表的类型
1）根据范围进行分区，分区表达式可以是列，也可以是包含列的表达式。比如可以每一年的销售额存放在不同分区：
```
create table sales(
	order_date datetime not null,
	----other cols
) engine=innodb partition by range(year(order_date))(
	partition p_2010 values less than (2010),
	partition p_2011 values less than (2011),
	partition p_2012 values less than (2012),
	partition p_catchall values less than maxvalue
);
```
partition 分区子句可以使用各种函数，但有一个要求，表达式返回的值要是一个确定的整数，且不能是一个常数。这里我们也可以使用to_days()等
2）支持哈希分区
3）列表分区
4）根据键值分区，来减少innodb的互斥量竞争
5）使用数学模函数来进行分区，然后将数据轮询放入不同的分区。例如可以对日期做模7的运算，或者更简单的使用返回周几的函数，如果只想保留最近几天的数据，这样分区更方便。
6）假设表有一个自增的主键列id，希望根据时间将最近的热点数据集中存放。那么必须将时间戳包含在主键当做才行，而这和主键本身的意义相矛盾。这种情况下也可以使用这样的分区表达式来实现相同的目的：hash(id div 1000000),这将为100万的数据建立一个分区。
这样一方面实现了当初的分区目的，另一方面比起使用时间范围分区还避免了一个问题，就是当超过一定阀值时候，如果使用时间范围分区就必须新增分区。

## 4、如何使用分区表

在数据量超大的时候，B-Tree索引就无法起作用了。除非是覆盖索引查询。否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，这将产生大量的随机I/O，随之数据库的响应时间将大到不可接受的程度。另外索引维护（磁盘空间，I/O操作）的代价也非常高。

理解分区的时候还可以将其作为索引的最初状态，以代价非常小的方式定位到需要的数据在哪一片区域。在这篇区域中，你可以做顺序扫描，可以建索引，还可以将数据缓存到内存等等。。因为分区无须额外的数据结构记录每个分区有哪些数据，分区不需要精准定位每条数据的位置，也就无须额外的数据结构，所以代价非常低。只需要一个简单的表达式就可以表达每个分区存放的是什么数据。

为了保证大数据量的可扩展性，一般有下面两个策略：
1）全量扫描数据，不要任何索引
可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能够使用where条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足要求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在磁盘上，因为内存相对娇小，数据很快会被挤出内存，索引加缓存起不了任何作用。
这个策略适用于以正常的方式访问大量数据的时候。警告：后面我们会详细解释，必须将查询需要扫描的分区个数限制在一个很小的数量。

2）索引数据，并分离热点
如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样的查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存。


## 5、什么情况下分区会出问题
1）null值会使得分区过滤无效
2）分区列和索引列不匹配
3）选择分区的成本可能很高
4）打开并锁住所有底层表的成本可能很高
5）维护分区的成本可能很高

以下是分区实现中的一些限制
1）所有分区都必须使用相同的存储引擎
2）分区函数中国可以使用的函数和表达式也有一些限制
3）某些存储引擎不支持分区
4）对于myisam的分区表，不能再使用load index into cache操作
5）对于myisam表，使用分区表时候需要打开更多的文件描述符

## 6、查询优化
分区最大的优点就是优化器可以根据分区函数来过滤一些分区。根据粗粒度索引的优势，通过分区过滤通常可以让查询扫描更少的查询（在某些场景下）。

所以，对于访问分区表来说，很重要的一点就是要在where条件中带入分区列，有时候即使看似多余的也要带上，这样可以让优化器能够过滤掉无须访问的分区。


使用explain partition来观察优化器是否执行了分区过滤：
```
//可以看到使用了p_2010,p_2011,p_2012
explain partition select * from sales \G 
//可以看到使用了p_2011,p_2012
explain partition select * from sales_by_day where day>'2011-01-01' \G
//下面这个查询看似可以过滤分区，而实际却不行，看出来还是p_2010,p_2011,p_2012
explain partition select * from sales_by_day where year(day)=2010 \G
```

注意：mysql只能在使用分区函数的列本身进行比较时候才能过滤分区，而不能根据表达式值去过滤分区，即使这个表达式就是分区函数也不行。
所以上边第三个查询可以改写成
```
explain partition select * from sales_by_day where day between '2011-01-01' and '2011-12-32' \G
```
注意：即使创建分区时候可以使用表达式，但在查询时候却只能根据列来过滤分区。


## 7、合并表
合并表是一种早起的、简单额分区实现，和分区表相比有一些不同的限制，并且缺乏优化。分区表严格来说是一个逻辑上的概念，用户无法访问底层的各个分区，对用户来说分区是透明的。但是合并表允许用户单独访问各个子表。分区表和优化器的结合更加紧密，这也是为了发展的趋势，而合并表则是一种被淘汰的技术，在未来版本中可能被删除。
删除一个合并表，他的子表不会受任何影响，而如果删除其中的一个子表可能会有不同的后果，这要视操作系统而定。

## 8、视图
### 8.1 视图概要
mysql5.0之后开始引入视图。视图本身是一个虚拟表，不存放任何数据。在使用sql语句访问视图的时候，他返回的数据是mysql从其他表中生成的。视图和表是在同一个命名空间，mysql在很多地方对于视图和表是同样对待的。不过也有不同，比例：必能对视图创建触发器，也不能使用drop table删除视图。
eg:
```
create view test_view as 
	select * fromt test where last_name='tom' with check option;
```

mysql可以使用两种算法来处理视图，分别是合并算法（将视图定义的sql合并进查询sql）和临时表算法。
如果可能的话，尽可能的使用合并算法。mysql甚至可以嵌套的定义视图，也就是在一个视图上再定义另外一个视图。可以explain extended 之后再使用show warnings 来查看使用视图的查询重写后的结果。

视图的好处：
1）视图能简化用户操作
视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。
2） 视图使用户能以多种角度看待同一数据
视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。
3）视图对重构数据库提供了一定程度的逻辑独立性
数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。
4）视图能够对机密数据提供安全保护
对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。
例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。
5）适当的利用视图可以更清晰地表达查询


注意：如果视图中包含group by ,distinct ,任何聚合函数,union，子查询等，只要无法再原表记录和视图记录中建立一一映射的场景中，mysql都将使用临时表算法来实现视图。上边列举的可能不全，而且这些规则在未来的版本中也可能会改变。如果你想确定mysql到底是使用合并算法还是临时表算法，可以explain一条针对视图的简单查询。
eg:
select * from view_name;
这里的select_type=detived（导出、起源、由来），说明视图是采用临时表算法来实现的。

视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。
例如，可以为一个基于简单查询的视图使用临时表算法：
```
create algorithm=temptable view v1 as select * from actor;
```
这个查询实现该视图本身不需要临时表，但基于该视图无论执行什么样的查询，视图都会生成一个临时表。

### 8.2 可更新视图
可更新视图是指可以通过更新这个视图来更新视图涉及的相关表。只要指定了合适的条件，就可以更新、删除甚至向视图中写入数据。
下面几种情况不能更新;
1）所有使用临时表算法实现的视图都无法被更新
2）更新的视图查询也可以是一个关联语句，但是一个限制，被更新的列必须来自同一个表
3）8.1中使用的check option子句中，表示任何通过视图更新的行，都必须符合视图本身的where条件定义。所以不能更新视图定义列以外的列。

### 8.3 视图对性能的影响
实际上，在mysql中，某些情况下视图可以帮助提升性能。而且视图还可以和其他提升性能的方式叠加使用。

可以使用视图实现基于列的权限控制，却不需要真正的在系统中创建列权限。因此没有额外的开销。
```
create view public.employeeinfo as 
	select fname,lname from private.employeeinfo;
	
grant select on public.* to merize;
```

有时候也可以使用伪临时视图实现一些功能。mysql虽然不能创建只在当前连接中存在的真正临时视图，但是可以创建一个特殊名字的视图，然后在连接结束的时候删除该视图。这样在连接过程中就可以在from子句中使用这个视图，和使用子查询的方式完全相同，因为mysql在处理视图和处理子查询的代码路径完全不同，所以他们的性能也不同。
```
// assuming 1234 us the result of connection_id()
create view temp.cost_per_day_1234 as 
	select date(ts) as day,sum(cost) as cost  from logs.cost group by day;

select c.day,c.cost,s.sales from temp.cost_per_day as s using(day);

drop view temp.cost_per_day_1234;
```
我们这里使用连接id作为视图名字的一部分来避免冲突。在应用发送崩溃和别意外导致未清理临时视图的时候，这个技巧使得清理临时视图变得很简单。


使用临时表算法实现的视图，在某些时候性能也会很糟糕（虽然可能比直接使用等效查询语句好些）。mysql以递归的方式执行这类视图，先会执行外层查询，即使外层查询优化器将其优化得很好，但是mysql优化器可能无法像其他数据库那样做更多的内外结合的优化。外层查询的where条件也无法“下推”到构建视图的临时表的查询中，临时表也无法建立索引。


如果是两个视图做关联的话，优化器就没有任何索引可以使用了。

视图还引入了一些并非mysql特有耳朵其他问题，很多人以为视图很简单，但实际上背后的逻辑可能很复杂。

如果打算使用视图来提升性能，需要做比较详细的测试。视图的性能也很难预测，而且视图本身可能会有一些隐藏缺陷和问题。所以视图即使是使用合并算法实现的-并不总是有很优化的实现。

### 8.4 视图的限制
可能其他的关系型数据库支持物化视图，但是mysql还不支持物化视图（物化视图指的是视图结果集数据存放在一个可以查看的表中，并定期从原始表中刷新数据到这个表中）。
mysql也不支持在视图中创建索引，不过可以使用创建缓存表或者汇总表的办法来模拟物化视图和索引。

视图实现上也有一些令人烦恼的地方。例如：mysql并不会保存视图定义的原始sql语句，所以如果打算通过执行show create view后再简单修改其结果的方法来重新定义视图，可能会大失所望。show create view出来的视图创建语句将以一种不友好的内部格式呈现，充满了各种转义符合引号，没有代码格式化，没有注释，也没有缩进。



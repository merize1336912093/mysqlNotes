[toc]
# mysql读书笔记之七

标签（空格分隔）： mysql

## 1、外键约束
innodb是目前mysql中唯一支持外键的内置存储引擎，索引如果需要外键支持，那么选择就不多了（PBXT也有外键支持）。
使用外键是有成本的。比如外键通常都要求每次在修改数据时候都要在另外一张表中多执行一次查找操作。虽然innodb强制外键使用索引，但还是武大消除这种约束检查的开销，如果外键列的选择性很低，则会导致一个非常大且选择性很低的索引。

不过，在某些场景下，外键会提升一些性能。如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性的性能要高的多，此外，外键在相关数据的删除和更新上，也比在应用中维护要更高效。不过外键维护操作是逐行进行的，所以这样的更新会比批量删除和更新要慢些。

外键约束是的查询需要额外访问一些表，这也意味着需要额外的锁。这样就可能会导致额外的锁等待，甚至会导致一些死锁。因为没有直接访问这些表，所以这类思索问题往往难以排查。

有时候会用触发器来代替外键。对于相关数据的同时更新，外键更合适，但是如果外键只是用作数值约束，那么触发器或者显示的限制取值会更好些（这里可以直接使用enum类型）。

## 2、在mysql内部存储代码及优缺点
mysql通过触发器、存储过程、函数的形式来存储代码。从5.1开始，在定时任务中存放代码，这个定时任务就叫“事件”。存储过程和存储函数都被统称为“存储程序”。
不同类型的存储代码的主要区别在于执行的上下文-也就是输入和输出。存储过程和存储函数都可以接收参数然后返回值，但是触发器和事件却不行。

一般来时候，存储代码是一种很好的共享和复用代码的方法。但有的人倡导，有的人不倡导，看下面额优缺点。
优点：
1）他在服务器内部执行，离数据最近，另外在服务器上执行还可以节省带宽和网络延迟。
2）这是一种代码重用。可以方便的统一业务规则，保证某些行为总是一致的，所以可以为应用提供一定的安全性。
3）他可以简化代码的维护和版本更新
4）他可以帮助提升安全，比如提升更细粒度的权限控制。应用程序也可以通过存储过程接口访问那些没有权限的表。例如银行转移资金的存储过程。
5）服务器端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会大大降低消耗。
6）因为是在服务器端部署的，所以备份、维护都可以在服务器端完成，存储程序的维护工作简单，因为没有什么外部依赖。
7）他可以在应用开发和数据库开发人员之间更好的分工。不过最好是由数据库专家来开发存储过程，因为不是每个应用开发人员都能写出高效的sql查询。

缺点：
1）mysql本身没有提供好用的开发和调试工具，所以编写mysql的存储过程代码比其他的数据库要更难些。
2）较之应用程序大代码，存储代码效率要稍微差些。例如，存储代码中可以使用的函数非常有限，所以使用存储代码很难编写复杂的字符串维护功能，也很难实现太复杂的逻辑。
3）存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外的部署mysql内部的存储代码。
4）因为存储程序都部署在服务器内，所以可能会有安全隐患。如果将非标准的加密功能放在存储程序中，那么若数据库被攻破，数据也就泄露了。但若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获取数据。
5）存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多。
6）mysql并没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死。
7）存储代码在mysql中的实现也有很多限制-执行计划缓存是连接级别的，游标的物化和临时表相同，在5.5之前，异常处理也非常困难等等。简而言之，较之T-SQL或者PL/SQL，mysql的存储代码功能还非常非常弱。
8）调试mysql的存储过程很困难。如果慢日志只是给出call xyz('a')，通常很难定位到到底是什么问题导致的，这时候不得不去看存储过程中的sql语句是如何编写的。
9）他和基于语句的二进制日志复制合作的并不好，在基于语句的复制中，使用存储代码通常有很多的陷阱，除非你在这个方面的经验非常丰富或者非常有耐心排查这列问题，否则需要谨慎使用。

最后，总结下，存储代码是一种帮助应用隐藏复杂性，使得应用开发更简单方法。不过他的性能可能更低，而且会给mysql的复制等增加潜在的风险。在使用存储代码之前，需要问问自己，希望程序逻辑在哪儿实现，是数据库中还是应用代码中。

### 2.1 存储过程和函数
mysql的架构本身和优化器的特性使得存储代码有一些天然的限制，他的性能也一定程度受制于此。如下：
1）优化器无法使用关键字deterministic（单词意思是确定性的）来优化单个查询中多次调用存储函数的情况。
2）优化器无法评估存储函数的执行成本
3）每个连接都有独立的存储过程的执行计划缓存。如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来反复缓存同样的执行计划。（如果使用的是连接池或者是持久化连接，那么执行计划缓存可能会有更长的生命周期。）
4）存储程序和复制是一组诡异的组合。如果可以最好不要复制对存储程序的调用。直接复制由存储程序改变的数据则会更好。mysql5.1引入的行复制能够改善这个问题。

eg:
```
drop procedure if exists insert_many_rows;
delimiter //

create procedure insert_many_rows(IN loops INT)
begin
	declare v1 int;
	set v1=loops;
	while v1>0 do 
		insert into test_table_values(null,0,'dadszdsf', 'fdsfsegrsfdg');
	    set v1 = v1-1;
	end while;
end;
//
delimiter;
```
如果存储过程快很多，很大程度因为他无须网络开销、解析开销和优化器开销等。

### 2.2 触发器（279）
触发器在执行insert,update,delete的时候没执行一些特定的操作，可以在mysql中指定是sql语句执行前触发还是在执行后触发。触发器本身没有返回值，不过他们可以读取或者改变触发sql语句所影响的数据，所以，可以使用触发器实现一些强制限制，或者某些业务逻辑，否则就需要在应用程序中实现这些逻辑。
使用触发器可以减少客户端和服务器端的通信，所以可以简化应用逻辑，还可以提升性能。
另外，还可以用于自动更新反范式化数据或者汇总表数据。

mysql的触发器特别注意：
1）对每个表的每个事件，最多定义一个触发器（换句话说，不能在after insert上定义两个触发器）
2）mysql只支持“基于行触发”-也就是说，触发器始终是真毒一条记录的，而不是针对整个sql语句的。如果变更的数据集非常大的话，效率会很低。

下面这些触发器本身的限制也适用于mysql:
1）触发器可以掩盖很多服务器背后的工作
2）触发器的问题很难排查，如果某个性能问题和触发器有关，会很难分析和定位
3）触发器可能导致死锁和锁等待。如果触发器失败，那么原来的sql语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码是什么意思。


如果仅仅考虑性能，那么mysql触发器的实现中对服务器限制最大的就是他的“基于行的触发”设计。因为性能原因，很多时候无法使用触发器来维护汇总表和缓存表。使用触发器也不是批量更新的一个重要原因就是使用触发器可以保证数据总是一致的。

触发器并不能一定保证更新的原子性。比如，一个触发器在更新myisam表的时候默认给遇到什么错误，会抛出错误，但是没有办法做回滚操作的。

在innodb表上的触发器是在同一个事务中完成的，所以他们只想的操作是原子的，原操作和触发器操作会同时成功或失败。不过，如果在innodb表上建触发器去检查数据的一致性，需要特别小心MVCC(多版本并发控制)。

可以使用触发器来记录数据变更日志。
如果触发器基于有自增主键的记录，并且使用的是基于语句的复制，那么自增长可能会在主从复制中出现的不一致。

row_count()：在mysql中国只有真正对记录做了修改，才会去记录影响行数。
判断select得到的行数用found_rows()函数，判断update,insert或者delete影响行数用row_count()函数。


### 2.3 事件
事件需要的考虑的：
1）创建事件意味着给服务器带来额外的工作。事件实现机制本身的开销不大，但是事件需要执行sql,则可能会对性能有很大的影响。
2）事件和其他的存储程序一样，在和基于语句的复制一起工作时候，也可能会触发同样的问题。
事件的一些典型应用包括定期地维护任务、重建缓存、构建汇总表来模拟物化视图，或者存储用于监控和诊断的状态值。

例子：
创建一个事件，会每周一次针对某个数据库运行一个存储过程：
```
create event optimize_somedb on schedule every 1 week 
do 
call optimize_tables('somedb')
```
如果一个定时事件本身执行需要很长的时间，那么有可能会出现这样的情况，即前面有个事件还未执行完成，下一个时间点的事件又开始了，mysql本身并不会防止这种并发，所以需要用户自己编写这种情况下的防并发代码，你可以使用函数get_lock()来确保当前总是一个事件在被执行：
```
create event optimize_somedb on shedule every 1 week 
do 
begin
	declare continue hanlder for sqlexception 
		begin end;
	if get_lock('somedb', 0) then 
		do call optimize_tables('somedb');
	end if;
	do release_lock('somedb');
end
```
这里的“continue hanlder”用来确保，即使当事件执行出现了异样，仍然会释放持有的锁。
虽然事件的执行是和连接无关的，但是他仍然是线程级别的。mysql中有一个事件调度线程，必须在mysql配置文件中设置，或者使用下面的命令来设置：
```
set global event_scheduler := 1;
```	
该选项一旦设置，该线程就会执行各个用户指定的事件中的各段sql代码，你可以通过观察mysql的错误日志来了解事情的执行情况。

虽然事件调度是一个单独的线程，但是事件本身是可以并行执行的。

### 2.4 在存储过程中保留注释
一个将注释存储到存储程序中的技巧是使用版本相关的注释，因为这样的注释可能被mysql服务器执行（例如，只有版本号大于某个值的时候才执行的代码）。

### 2.5 游标
游标指的是一个可读的标识，用来标识数据取到什么地方了。特性：只读、不滚动、不敏感。
很重要的一点：
当你打开一个游标的时候需要执行整个查询。考虑下面的存储过程：
```
create procedure bad_cursor()
begin 
	declare film_id int;
	declare f cursor for select film_id from sakila.film;//定义游标
	open f;//游标open
	fetch f into film_id;//游标fetch
	close f;//游标close
end
```
从这个例子可以看出不用处理完所有的数据就可以关闭游标。使用oracle或者sqlserver的用户不会认为这个存储过程会有什么问题，但是在mysql中，这会带来很多不必要的额外操作。使用show status来诊断这个存储过程，可以看到她需要做1000个索引页的读取，做1000个写入。这是因为表sakila.film中有1000条记录，而所有这些读和写都发送再第五行的打开游标动作。

这个案例告诉我们，如果关闭游标的时候只是扫描了一个大结果集的一小部分，那么存储过程可能不仅么有减少开销，相反带来了大量的额外开销。这时候需要使用limit来限制返回的结果集。

游标也会让mysql执行一些额外的I/O操作，而这些操作的效率可能非常低。如果游标返回blob和text这些类型的列（这些列内存表不支持），mysql就必须在磁盘上创建临时表，或者即使没有这样的列，临时表大于tmp_table_size的时候，也会创建临时表。

mysql不支持客户端游标，不过客户端api可以通过缓存全部查询结果的方式模拟客户端的游标。




